function [links] = stack_FRS_3D(R, phi_dot_0, options)
%STACK_FRS given the initial configuration and velocities of an n-link
% arm, generates the FRS of each link
% 2nd link FRS is generated by stacking two one link FRS's together
% so on and so forth for 3rd link onwards
% R is nx1 cell containing rotation matrices for n links
% phi_dot_0 is nx1 column vector containing initial angular velocities
% NOTE: in this implementation, I am assuming that the "z" axis specified
% by each R is the axis around which the angular velocity is phi_dot_0, and
% that there is no initial angular velocity about any other axis.

load('FRS_3D/0key')

% z_0 = cumsum(x_0);
% z_dot_0 = cumsum(x_dot_0);

if length(R) ~= options.nLinks
    error('Cell array of rotation matrices is not the expected length');
end

if length(phi_dot_0) ~= options.nLinks
    error('Vector of initial velocities is not the expected length');
end

nP = length(options.position_dimensions);
nQ = length(options.extra_position_dimensions) + length(options.IC_dimensions) + length(options.param_dimensions) + 1;
nK = length(options.param_dimensions);

% update the param_dimensions for once we remove the initial conditions and
% extra position dimensions
options.new_param_dimensions = options.param_dimensions - length(options.IC_dimensions) - length(options.extra_position_dimensions);

for i = 1:options.nLinks
%     myA11 = [cos(z_0(i)), -sin(z_0(i));...
%            sin(z_0(i)), cos(z_0(i))];
    myA11 = R{i};
    myA12 = zeros(nP, nQ);
    myA21 = zeros(nQ, nP);
    myA22 = eye(nQ, nQ);
    A{i} = [myA11, myA12; myA21, myA22]; % construct "rotation" matrix
    
    [~, closest_idx] = min(abs(phi_dot_0(i) - c_IC(1, :)));
    filename = sprintf('FRS_3D/arm_FRS_%0.3f_0.000.mat', c_IC(1, closest_idx));
    file{i} = load(filename, 'Rcont', 'RcontEE', 'options');
    Rcont{i} = file{i}.Rcont;
    RcontEE{i} = file{i}.RcontEE;
end

links = cell(options.nLinks, 1);
% tic;
% rotate and stack Rcont to get FRSs of links
for i = 1:length(Rcont{1})
    for j = 1:length(Rcont)
        % remove extraneous dimensions
        
        %%%%%%%%%%%%%%%%%%%%%%%%
       
        % slice along initial conditions
        myZ = zonotope_slice(Rcont{j}{i}{1}, options.IC_dimensions, [phi_dot_0(j); 0]);
        myZEE = zonotope_slice(RcontEE{j}{i}{1}, options.IC_dimensions, [phi_dot_0(j); 0]);
        
        % get matrix representation
        myZ = get(myZ, 'Z');
        myZEE = get(myZEE, 'Z');
        
        % rotate the zonotope by initial configurations
        myZ = A{j}*myZ;
        myZEE = A{j}*myZEE;
                
        % remove generators associated with initial condtions and extra
        % position dimensions
        myZ([options.extra_position_dimensions; options.IC_dimensions], :) = [];
        myZEE([options.extra_position_dimensions; options.IC_dimensions], :) = [];
                
        % save zonotope matrices
        Z{j} = myZ;
        ZEE{j} = myZEE;
        
        %%% now stack previous links together:
        mytimestep = file{j}.options.timeStep;
        nGen = size(Z{j}, 2) - 1;
        myzeros = zeros(1, nGen);
        
        stack_c = zeros(nP + j*nK + 1, 1);
        stack_G = zeros(nP + j*nK + 1, j*nGen);
        for k = 1:j
            if k == j
                stack_c(options.position_dimensions, 1) = stack_c(options.position_dimensions, 1) + Z{k}(options.position_dimensions, 1);
                stack_c(nP + (nK*(k-1)+1:nK*k)', 1) = Z{k}(options.new_param_dimensions, 1);
                
                stack_G(options.position_dimensions, (k-1)*nGen+1:k*nGen) = Z{k}(options.position_dimensions, 2:end);
                stack_G(nP + (nK*(k-1)+1:nK*k)', (k-1)*nGen+1:k*nGen) = Z{k}(options.new_param_dimensions, 2:end);
            else
                stack_c(options.position_dimensions, 1) = stack_c(options.position_dimensions, 1) + ZEE{k}(options.position_dimensions, 1);
                stack_c(nP + (nK*(k-1)+1:nK*k)', 1) = ZEE{k}(options.new_param_dimensions, 1);
                
                stack_G(options.position_dimensions, (k-1)*nGen+1:k*nGen) = ZEE{k}(options.position_dimensions, 2:end);
                stack_G(nP + (nK*(k-1)+1:nK*k)', (k-1)*nGen+1:k*nGen) = ZEE{k}(options.new_param_dimensions, 2:end);
            end
        end
        
        % deal with time step
        stack_c(end, 1) = Z{j}(end, 1);
        stack_G = [[zeros(nP + j*nK, 1); mytimestep], stack_G];
        
        % construct FRS
        links{j}.FRS{i} = zonotope([stack_c, stack_G]);
        
        % save some info:
        links{j}.info.position_dimensions = options.position_dimensions;
        for k = 1:j
            links{j}.info.param_dimensions((nK*(k-1)+1:nK*k)', 1) = options.new_param_dimensions + nK*(k-1);
        end
        links{j}.info.max_params = options.nLinks*nK;
    end
end

end